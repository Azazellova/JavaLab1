<h1>Лабораторная работа №1</h1>
<h2>
  <p>Мазур София</p>
  <p>7 группа</p>
</h2>
<p>
  Для удобного вывода всех задач использовался switch.
</p>
<h2>Задание 1. Методы</h2>

<h3>1. Дробная часть</h3>
<p><strong>Сигнатура метода:</strong> <code>public double fraction(double x);</code></p>
<p>Реализовать метод так, чтобы он возвращал только дробную часть числа x.</p>
<p><strong>Пример:</strong> x=5,25 → результат: 0,25</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Используем оператор остатка от деления % 1, который возвращает дробную часть числа.</p>

<h3>3. Букву в число</h3>
<p><strong>Сигнатура метода:</strong> <code>public int charToNum(char x);</code></p>
<p>Метод принимает символ x, который представляет собой одну из цифр '0'–'9'. Необходимо преобразовать символ в соответствующее число. Подсказка: код символа ‘0’ — это число 48</p>
<p><strong>Пример:</strong> x=’3’ → результат: 3</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Используем разность кодов символов. В подсказке написано, что ‘0’ — это число 48. Следовательно, код символа цифры минус код символа '0' дает саму цифру.</p>

<h3>5. Двузначное</h3>
<p><strong>Сигнатура метода:</strong> <code>public bool is2Digits(int x);</code></p>
<p>Метод должен возвращать true, если число x является двузначным.</p>
<p><strong>Пример 1:</strong> x=32 → результат: true<br>
<strong>Пример 2:</strong> x=516 → результат: false</p>

<p><strong>Алгоритм решения:</strong></p>
<p> Проверяем, что число находится в диапазоне от 10 до 99 включительно.</p>

<h3>7. Диапазон</h3>
<p><strong>Сигнатура метода:</strong> <code>public bool isInRange(int a, int b, int num);</code></p>
<p>Метод возвращает true, если num входит в диапазон от a до b (включая границы). Отношение a и b заранее неизвестно.</p>
<p><strong>Пример 1:</strong> a=5, b=1, num=3 → результат: true<br>
<strong>Пример 2:</strong> a=2, b=15, num=33 → результат: false</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Сначала определяем, какая граница больше, затем проверяем попадание числа в диапазон.</p>

<h3>9. Равенство</h3>
<p><strong>Сигнатура метода:</strong> <code>public bool isEqual(int a, int b, int c);</code></p>
<p>Метод возвращает true, если все три числа равны.</p>
<p><strong>Пример 1:</strong> a=3, b=3, c=3 → результат: true<br>
<strong>Пример 2:</strong> a=2, b=15, c=2 → результат: false</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Проверяем попарное равенство всех трех чисел.</p>

<h2>Задание 2. Условия</h2>

<h3>1. Модуль числа</h3>
<p><strong>Сигнатура метода:</strong> <code>public int abs(int x);</code></p>
<p>Метод возвращает модуль числа x.</p>
<p><strong>Пример 1:</strong> x=5 → результат: 5<br>
<strong>Пример 2:</strong> x=-3 → результат: 3</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Если число отрицательное, умножаем на -1, иначе возвращаем как есть.</p>

<h3>3. Тридцать пять</h3>
<p><strong>Сигнатура метода:</strong> <code>public bool is35(int x);</code></p>
<p>Метод возвращает true, если число x делится нацело на 3 или 5, но не на оба одновременно.</p>
<p><strong>Пример 1:</strong> x=5 → результат: true<br>
<strong>Пример 2:</strong> x=8 → результат: false<br>
<strong>Пример 3:</strong> x=15 → результат: false</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Проверяем делимость на 3 или 5, но исключаем случай одновременной делимости на оба числа.</p>

<h3>5. Тройной максимум</h3>
<p><strong>Сигнатура метода:</strong> <code>public int max3(int x, int y, int z);</code></p>
<p>Метод возвращает максимальное из трёх чисел.</p>
<p><strong>Пример 1:</strong> x=5, y=7, z=7 → результат: 7<br>
<strong>Пример 2:</strong> x=8, y=-1, z=4 → результат: 8</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Последовательно сравниваем числа, находя максимальное.</p>

<h3>7. Двойная сумма</h3>
<p><strong>Сигнатура метода:</strong> <code>public int sum2(int x, int y);</code></p>
<p>Метод возвращает сумму x и y, но если сумма в диапазоне от 10 до 19, то возвращает 20.</p>
<p><strong>Пример 1:</strong> x=5, y=7 → результат: 20<br>
<strong>Пример 2:</strong> x=8, y=-1 → результат: 7</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Складываем числа и проверяем, попадает ли сумма в диапазон 10-19.</p>

<h3>9. День недели</h3>
<p><strong>Сигнатура метода:</strong> <code>public String day(int x);</code></p>
<p>Метод возвращает название дня недели, где 1 – понедельник, 7 – воскресенье. Использовать switch.</p>
<p><strong>Пример:</strong> х=5 → результат: “пятница”</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Используем switch для сопоставления номера дня с его названием</p>

<h2>Задание 3. Циклы</h2>

<h3>1. Числа подряд</h3>
<p><strong>Сигнатура метода:</strong> <code>public String listNums(int x);</code></p>
<p>Метод возвращает строку с числами от 0 до x включительно.</p>
<p><strong>Пример:</strong> х=5 → результат: “0 1 2 3 4 5”</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Проходим циклом от 0 до x, добавляя числа в строку с пробелами.</p>

<h3>3. Четные числа</h3>
<p><strong>Сигнатура метода:</strong> <code>public String chet(int x);</code></p>
<p>Метод возвращает строку с чётными числами от 0 до x включительно. Без использования if.</p>
<p><strong>Пример:</strong> x=9 → результат: “0 2 4 6 8”</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Используем шаг 2 в цикле для получения только четных чисел.</p>

<h3>5. Длина числа</h3>
<p><strong>Сигнатура метода:</strong> <code>public int numLen(long x);</code></p>
<p>Метод возвращает количество цифр в числе x.</p>
<p><strong>Пример:</strong> x=12567 → результат: 5</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Делим число на 10 до тех пор, пока оно не станет равным 0, подсчитывая количество итераций.</p>

<h3>7. Квадрат</h3>
<p><strong>Сигнатура метода:</strong> <code>public void square(int x);</code></p>
<p>Метод выводит квадрат из символов '*' размером x×x.</p>
<p><strong>Пример 1:</strong> x=2 → результат:<br>
**<br>
**<br>
<strong>Пример 2:</strong> x=4 → результат:<br>
****<br>
****<br>
****<br>
****</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Используем вложенный цикл для вывода x строк по x символов '*' в каждой.</p>

<h3>9. Правый треугольник</h3>
<p><strong>Сигнатура метода:</strong> <code>public void rightTriangle(int x);</code></p>
<p>Метод выводит выровненный по правому краю треугольник из '*'.</p>
<p><strong>Пример 1:</strong> х=3 → результат:<br>
&nbsp&nbsp*<br>
&nbsp**<br>
***<br>
<strong>Пример 2:</strong> х=4 → результат:<br>
&nbsp&nbsp&nbsp*<br>
&nbsp&nbsp**<br>
&nbsp***<br>
****</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Объявляем переменную k, которая будет использоваться для выводов пробелов. Сначала выводим пробелы для выравнивания через цикл, затем выводим звездочки. Количество пробелов уменьшается с каждой строкой при помощи параметра k.</p>

<h2>Задание 4. Массивы</h2>

<h3>1. Поиск первого значения</h3>
<p><strong>Сигнатура метода:</strong> <code>public int findFirst(int[] arr, int x);</code></p>
<p>Метод возвращает индекс первого вхождения x в массив arr, или -1, если элемента нет.</p>
<p><strong>Пример:</strong> arr=[1,2,3,4,2,2,5], x=2 → результат: 1</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Линейный поиск по массиву с возвратом индекса первого совпадения.</p>

<h3>3. Поиск максимального</h3>
<p><strong>Сигнатура метода:</strong> <code>public int maxAbs(int[] arr);</code></p>
<p>Метод возвращает наибольшее по модулю значение в массиве.</p>
<p><strong>Пример:</strong> arr=[1,-2,-7,4,2,2,5] → результат: -7</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Проходим по массиву, сравнивая абсолютные значения элементов и выводим наибольшее значение.</p>

<h3>5. Добавление массива в массив</h3>
<p><strong>Сигнатура метода:</strong> <code>public int[] add(int[] arr, int[] ins, int pos);</code></p>
<p>Метод возвращает новый массив, в который в позицию pos вставлены все элементы массива ins.</p>
<p><strong>Пример:</strong> arr=[1,2,3,4,5], ins=[7,8,9], pos=3 → результат: [1,2,3,7,8,9,4,5]</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Создаем новый массив и копируем элементы в три этапа: до позиции вставки, вставляемый массив, оставшиеся элементы.</p>

<h3>7. Возвратный реверс</h3>
<p><strong>Сигнатура метода:</strong> <code>public int[] reverseBack(int[] arr);</code></p>
<p>Метод возвращает новый массив с элементами arr в обратном порядке.</p>
<p><strong>Пример:</strong> arr=[1,2,3,4,5] → результат: [5,4,3,2,1]</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Копируем элементы из исходного массива в новый в обратном порядке.</p>

<h3>9. Все вхождения</h3>
<p><strong>Сигнатура метода:</strong> <code>public int[] findAll(int[] arr, int x);</code></p>
<p>Метод возвращает массив индексов всех вхождений числа x в arr.</p>

<p><strong>Алгоритм решения:</strong></p>
<p>Сначала подсчитываем количество вхождений, затем создаем массив нужного размера и заполняем его индексами.</p>
<p><strong>Пример:</strong> arr=[1,2,3,8,2,2,9], x=2 → результат: [1,4,5]</p>




